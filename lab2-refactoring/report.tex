\documentclass{article}

\title{
	Refactoring Golf \\
	\large{Lab Report}
}

\author{
	Alessandro Frau (\#0000971546) \\
	Stefano Volpe (\#0000969766)
}

\begin{document}

\maketitle

\section{Our opinion on Refactoring Golf}

Refactoring Golf is a gamified lab activity. It is designed to familiarize you
with your development environment's refactoring tools. While (sensible)
gamification in learning is a successful strategy per se, this is especially
true in this specific case: allowing many different solutions enables
creativity, and assigning them distinct scores appeals to the student's
competitive spirit. It is also a challenge that adapts to the amount of effort
you are willing to put into it. You get to choose whether to settle for the
first solution that comes to mind or an optimized one. Aiming for anything in
between is also an option.

One common downside of wild gamification is convincing your student the
principles they're applying are also valid in real-life contexts. If the game
penalizes them each time their tests fail or they rewrite code manually, then
surely they'll use as many automated refactoring actions as possible. During
the game, that is. As long as they don't actually feel how faster and
fail-proof these methods really are, there's no catch in bringing this
experience into their workflow. Perhaps a "puzzle" mode alone is not enough: a
"speedrun" mode is also in order. Using life-sized, real-world use cases, the
speaker could challenge any of the partecipants, allowing them to use a
development environment of their choice. Speedrunning would also help showcase
how automated refactoring is far more trustworthy than fallible, hurried human
hands. Of course, for this pitch to become reality, some details need to be
figured out first. Namely, how to ensure the fairness of the challenge?

\section{What we have learned from Refactoring Golf}

Playing Refactoring Golf, we realized that different workflows can dramatically
impact the safety and duration of refactoring sessions, too. This insight will
certainly lead to expanding one's list of known automated refactoring actions,
but some questions remain open.

\begin{itemize}
	\item Are the most advanced refactoring actions available on IDEs only? Even
	      if that were the case, the most experienced users wouldn't compromise
	      and stick with their single code editor of choice.
	\item The most powerful features seem awfully language specific. What about
	      settling for the ones that can be implemented above the Language Server
	      Protocol or similars, regardless of the current programming language?
	\item When it comes to modal editors, power users do not work with automated
	      refactoring almost at all. Does that mean modal editing is to be
	      considered a superior workflow?
	\item The amount of keyboard shortcuts to be memorized is absurd. Would
	      redefining them as composable keybindings help mitigating the issue?
\end{itemize}

\end{document}
